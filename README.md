# Tragedy

Tragedy is a high-level Cassandra abstraction for Python.

## Tragedy's Data Model

Tragedy makes it easy to quickly build your data model from Models and Indexes. A *Model* is a collection of data that can be accessed via a RowKey, and an *Index* is a 1-N mapping from one RowKey to one or more Models. A RowKey is just a unicode string. We usually use unique identifiers like usernames or email addresses or the RowKey, or when there's no good unique identifier, tragedy can generate a UUID.

Here's an example:

	class Tweet(Model):
    	uuid    = RowKey(autogenerate=True) # generate a UUID for us.
    	message = StringField()    
    	author  = ForeignKey(foreign_class=User, mandatory=True)

Tweet is a Model, analogous to a Python class. If we instantiate Tweet, we get a specific tweet that we can write to the database:

    new_tweet = Tweet(message="Twittering from tragedy!", author='merlin')
	new_tweet.save()

Tweet instances are referred to and accessed by a RowKey, which in this case named `uuid` and autogenerated on save. The only way to find an object in the database, is by its RowKey. Since in this case the RowKey is a random UUID, we have no way to find this particular tweet ever again if we ever lose the UUID. Thus it's clear we need to keep track of our UUIDs somewhere. E.g. we could keep a timeline of tweets that a user has sent. So how do we do that? We can use an Index:

	class TweetsSent(Index):
    	by_username = RowKey()
    	targetmodel = ForeignKey(foreign_class=Tweet, compare_with='TimeUUIDType')

	merlinIndex = TweetsSent(by_username='merlin')
	merlinIndex.append(new_tweet)
	merlinIndex.save()

This defines TweetsSent as an abstract Index over Tweets, sorted by Cassandra's TimeUUIDType. To work with a specifc TweetsSent-Index, we need to initialize an Index object with the RowKey - in this case the username. Once we've done that we can 1) append data to the index, as shown above, and 2) (re)load the index from the server:

    tweets_by_user = TweetsSent(by_username='merlin').load()
	print tweets_by_user

This gives us a list of Tweets, all initialized with the RowKeys of all tweets that user has sent. However the data of each tweet is still empty, because we've only loaded the Index from the database, not the Tweets themselves. Thus instead of seeing data, we'd see #MISSING# fields when displaying the list of tweets:

    [<Tweet 8649a1ca4ab843b9afa6cc954908ac04: {'message': '#MISSING#', 'author': '#MISSING#'}, ...]

To actually load the tweets we need to resolve them. Luckily that's easy:

	tweets_by_user.resolve()
	print tweets_by_user
	[<Tweet ced314748d574379a817e1a1c9149789: {'message': "some message", 'author': <User merlin: {'password': '#MISSING#'}>}>

Essentially Index.resolve() just calls Model.load() on each referenced Model, but is actually more efficient because it combines the queries into a multiquery, that can be processed more efficiently. You can't call .resolve() on Models though, since their data has structure. (Data of Indexes is always only a sorted keys to Models or other Indexes).

That's about it for the basics. There's more stuff like automatic validation if Cassandra and Tragedy agree on the DataModel. Take a look at the full example below:


## Example (full twitter-demo)

    import tragedy
    client = tragedy.connect(['localhost:9160'])
    from tragedy import *
    
    twitty_cluster  = Cluster('Twitty Cluster')
    twitty_keyspace = Keyspace('Twitty', twitty_cluster)
    
    ALLTWEETS_KEY = '!ALLTWEETS!' # virtual user that receives all tweets
    
    class User(Model):
        """A Model is stored and retrieved by its RowKey.
           Every Model has exactly one RowKey and one or more other Fields"""
        username  = RowKey()
        firstname = StringField(mandatory=False)
        lastname  = StringField(mandatory=False) # normally fields are mandatory
        password  = StringField()
    
        def follow(self, *one_or_more):
            fol = Following(username=self)
            for other in one_or_more:
                fol.append(other)
                FollowedBy(username=other).append(self).save()
            fol.save()
    
        def tweet(self, message):
            new_tweet = Tweet(author=self, message=message[:140]).save()
            TweetsSent(by_username=self).append(new_tweet).save()
            
            tr = TweetsReceived(by_username=ALLTWEETS_KEY)
            tr.append(new_tweet).save()
            
            for follower in self.get_followed_by():
                follower.receive(new_tweet)            
    
        def receive(self, tweet):
            TweetsReceived(by_username=self).append(tweet).save()
    
        def get_followed_by(self, *args, **kwargs):
            return FollowedBy(username=self).load(*args, **kwargs)
    
        def get_following(self, *args, **kwargs):
            return Following(username=self).load(*args, **kwargs)
    
        def get_tweets_sent(self, *args, **kwargs):
            return TweetsSent(by_username=self).load(*args, **kwargs).resolve()
    
        def get_tweets_received(self, *args, **kwargs):
            return TweetsSent(by_username=self).load(*args, **kwargs).resolve()
    
    class Tweet(Model):
        uuid    = RowKey(autogenerate=True) # generate a UUID for us.
        message = StringField()    
        author  = ForeignKey(foreign_class=User, mandatory=True)
    
        @staticmethod
        def get_recent_tweets(*args, **kwargs):
            tr = TweetsReceived(by_username=ALLTWEETS_KEY)
            return tr.load(*args, **kwargs).loadIterValues()
    
        # def __repr__(self):
        #     return '<%s> %s' % (self['author']['username'], self['message'])
    
    class TweetsSent(Index):
        """An index is an ordered mapping from a RowKey to
           instances of a specific Model."""
        by_username = RowKey()
        targetmodel = ForeignKey(foreign_class=Tweet, compare_with='TimeUUIDType')
    
    class TweetsReceived(Index):
        by_username = RowKey()
        targetmodel = ForeignKey(foreign_class=Tweet, compare_with='TimeUUIDType')
    
    class Following(Index):
        username = RowKey()
        targetmodel = ForeignKey(foreign_class=User, compare_with='TimeUUIDType', 
                                 unique=True)    
    
    class FollowedBy(Index):
        username = RowKey()
        targetmodel = ForeignKey(foreign_class=User, compare_with='TimeUUIDType',
                                 unique=True)
    
    # We're done with defining the Data Model. Let's verify that Cassandra agrees on the model!
    twitty_keyspace.verify_datamodel()
    # Ok, all set. Let's go!
    
    dave = User(username='dave', firstname='dave', password='test').save()
    merlin = User(username='merlin', firstname='merlin', password='sunshine').save()
    peter = User(username='peter', firstname='Peter', password='secret').save()
    
    dave.follow(merlin, peter)
    peter.follow(merlin)
    merlin.follow(dave)
    
    merlin.tweet("i've just started using twitty. send me a message!")
    dave.tweet('making breakfast')
    peter.tweet('sitting at home being bored')
    
    for dude in (dave,peter,merlin):
        name = dude['username']
        print '%s has these followers:' % (name,), dude.get_followed_by().values()
        print '%s follows' % (name,), dude.get_following().values()
        print '%s sent' % (name,), [x for x in dude.get_tweets_sent(count=3)]
        print '%s received' % (name,), [x for x in dude.get_tweets_received(count=3)]