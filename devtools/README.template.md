# Tragedy

Tragedy is a high-level Cassandra abstraction-layer for Python.

## Tragedy's Data Model

Tragedy makes it easy to quickly build your data model from Models and Indexes. A *Model* is a collection of data that can be accessed via a RowKey, and an *Index* is a 1-N mapping from one RowKey to one or more Models. A RowKey is just a unicode string. We usually use unique identifiers like usernames or email addresses or the RowKey, or when there's no good unique identifier, tragedy can generate a UUID.

Here's an example:

	class Tweet(Model):
    	uuid    = RowKey(autogenerate=True) # generate a UUID for us.
    	message = StringField()    
    	author  = ForeignKey(foreign_class=User, mandatory=True)

Tweet is a Model, analogous to a Python class. If we instantiate Tweet, we get a specific tweet that we can write to the database:

    new_tweet = Tweet(message="Twittering from tragedy!", author='merlin')
	new_tweet.save()

Tweet instances are referred to and accessed by a RowKey, which in this case named `uuid` and autogenerated on save. The only way to find an object in the database, is by its RowKey. Since in this case the RowKey is a random UUID, we have no way to find this particular tweet ever again if we ever lose the UUID. Thus it's clear we need to keep track of our UUIDs somewhere. E.g. we could keep a timeline of tweets that a user has sent. So how do we do that? We can use an Index:

	class TweetsSent(Index):
    	by_username = RowKey()
    	targetmodel = ForeignKey(foreign_class=Tweet, compare_with='TimeUUIDType')

	merlinIndex = TweetsSent(by_username='merlin')
	merlinIndex.append(new_tweet)
	merlinIndex.save()

This defines TweetsSent as an abstract Index over Tweets, sorted by Cassandra's TimeUUIDType. To work with a specifc TweetsSent-Index, we need to initialize an Index object with the RowKey - in this case the username. Once we've done that we can 1) append data to the index, as shown above, and 2) (re)load the index from the server:

    tweets_by_user = TweetsSent(by_username='merlin').load()
	print tweets_by_user

This gives us a list of Tweets, all initialized with the RowKeys of all tweets that user has sent. However the data of each tweet is still empty, because we've only loaded the Index from the database, not the Tweets themselves. Thus instead of seeing data, we'd see #MISSING# fields when displaying the list of tweets:

    [<Tweet 8649a1ca4ab843b9afa6cc954908ac04: {'message': '#MISSING#', 'author': '#MISSING#'}, ...]

To actually load the tweets we need to resolve them. Luckily that's easy:

	tweets_by_user.resolve()
	print tweets_by_user
	[<Tweet ced314748d574379a817e1a1c9149789: {'message': "i've just started using twitty. send me a message!", 'author': <User merlin: {'password': '#MISSING#'}>}>

Essentially Index.resolve() just calls Model.load() on each referenced Model, but is actually more efficient because it combines the queries into a multiquery, that can be processed more efficiently. You can't call .resolve() on Models though, since their data has structure. (Data of Indexes is always only a sorted keys to Models or other Indexes).

That's about it for the basics. There's more stuff like automatic validation if Cassandra and Tragedy agree on the DataModel. Take a look at the full example below:


## Example (full twitter-demo)

